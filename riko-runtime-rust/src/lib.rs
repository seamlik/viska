//! Runtime for wrapper code generated by Riko.
//!
//! End user need only to care about the types and functions at the root level. Anything in the
//! other modules are only used by generated code.

use ::jni::objects::JObject;
use ::jni::sys::jbyteArray;
use ::jni::JNIEnv;
use heap::Handle;
use std::error::Error;

pub mod heap;
pub mod jni;

/// Marshaled as a byte array.
pub trait MarshaledAsByteArray {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray;
}

impl MarshaledAsByteArray for Vec<u8> {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray {
        env.byte_array_from_slice(&self)
            .expect("Failed to marshal as a byte array!")
    }
}

impl<T: MarshaledAsByteArray, E: Error> MarshaledAsByteArray for Result<Option<T>, E> {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray {
        match self {
            Ok(None) => JObject::null().into_inner(),
            Ok(Some(value)) => value.to_jni(env),
            Err(err) => {
                jni::throw(env, err);
                JObject::null().into_inner()
            }
        }
    }
}

/// Object allocated in the heap.
///
/// These objects are allocated and freed on the Rust side while only expose a memory address to the
/// target side. Target code must integrate the manual memory management into its own mechanism as
/// those memory management strategy (usually garbage collection) is not aware of any native code.
pub trait HeapObject: Sized {
    fn into_handle_jni(self, _: &JNIEnv) -> Handle;
}

impl<T: HeapObject, E: Error> HeapObject for Result<T, E> {
    fn into_handle_jni(self, env: &JNIEnv) -> Handle {
        match self {
            Ok(obj) => obj.into_handle_jni(env),
            Err(err) => {
                jni::throw(env, &err);
                0
            }
        }
    }
}
