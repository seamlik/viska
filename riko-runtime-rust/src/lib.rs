//! Runtime for wrapper code generated by Riko.
//!
//! End user need only to care about the types and functions at the root level. Anything in the
//! other modules are only used by generated code.

use ::jni::objects::JObject;
use ::jni::sys::jbyteArray;
use ::jni::JNIEnv;
use heap::Handle;
use std::error::Error;

pub mod heap;
pub mod jni;

/// Marshaled as a byte array.
pub trait MarshaledAsBytes {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray;
}

impl MarshaledAsBytes for Vec<u8> {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray {
        env.byte_array_from_slice(&self)
            .expect("Failed to marshal as a byte array!")
    }
}

impl<T: MarshaledAsBytes, E: Error> MarshaledAsBytes for Result<T, E> {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray {
        match self {
            Ok(value) => value.to_jni(env),
            Err(err) => {
                jni::throw(env, err);
                JObject::null().into_inner()
            }
        }
    }
}

impl<T: MarshaledAsBytes> MarshaledAsBytes for Option<T> {
    fn to_jni(&self, env: &JNIEnv) -> jbyteArray {
        match self {
            None => JObject::null().into_inner(),
            Some(value) => value.to_jni(env),
        }
    }
}

/// Object allocated in the heap.
///
/// These objects are allocated and freed on the Rust side while only expose a memory address to the
/// target side. Target code must integrate the manual memory management into its own mechanism as
/// those memory management strategy (usually garbage collection) is not aware of any native code.
pub trait HeapObject: Sized {
    fn into_handle_jni(self, _: &JNIEnv) -> Handle;
}

impl<T: HeapObject, E: Error> HeapObject for Result<T, E> {
    fn into_handle_jni(self, env: &JNIEnv) -> Handle {
        match self {
            Ok(obj) => obj.into_handle_jni(env),
            Err(err) => {
                jni::throw(env, &err);
                0
            }
        }
    }
}
